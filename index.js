#!/usr/bin/env node

import { createWriteStream } from "fs"
import { readdir } from "fs/promises"
import path, { extname } from "path"

const supportedFontFileTypes = [".ttf", ".woff", ".woff2"]


/**
 * The weights map is used to determine the weight
 * of the font by checking the name for the appropriate
 * keyword ('name'). Therefore we use an array and must
 * assure if we avoid possible collisions:
 * 
 * e.g. 'light' needs to be checked after 'extralight'
 */
const normalWeight = 400
const weights = [
    { name: "thin", weight: 100 },
    { name: "extralight", weight: 200 },
    { name: "light", weight: 300 },
    { name: "regular", weight: normalWeight },
    { name: "normal", weight: normalWeight },
    { name: "medium", weight: 500 },
    { name: "semibold", weight: 600 },
    { name: "bold", weight: 700 },
    { name: "black", weight: 900 },
]

function extractArguments() {

    const args = process.argv.slice(2)

    const configMap = {
        "--source": "sourceDirectory",
        "-s": "sourceDirectory",
        "-t": "targetFile",
        "--target": "targetFile",
        "-o": "override",
        "--override": "override",
        "-f": "fontName",
        "--font-name": "fontName",
        "-v": "verbose",
        "--verbose": "verbose"
    }

    const config = {
        override: false,
        sourceDirectory: null,
        targetFile: null,
        fontName: null,
        verbose: false
    }

    let argName = null
    args.forEach((arg, index) => {
        if (arg.startsWith("-")) {
            if (!configMap[arg]) throw new Error(`Unknown argument '${arg}'`)
            if (["-v", "--verbose"].includes(arg)) config.verbose = true
            else if (["-o", "--override"].includes(arg)) config.override = true
            else
                argName = configMap[arg]
        } else if (argName) {
            config[argName] = arg
            argName = null
        } else if (index == args.length - 1) {
            config.sourceDirectory = arg
        } else {
            throw new Error(`Bad arguments: Error at position${index + 1}/${arg}`)
        }
    })

    if (!config.sourceDirectory) throw new Error("No font directory specified!")
    if (!config.targetFile) throw new Error("No target specified!")

    return config
}


function getAbsolutePaths({
    fontName = null,
    sourceDirectory = null,
    targetFile = null,
}) {
    return {
        sourceDirectoryFullPath: path.resolve(sourceDirectory),
        outputFileFullPath: path.resolve(targetFile),
        fontName: getFontName(fontName, sourceDirectory)
    }
}

function getFontName(fontName, outDirectory) {
    if (!fontName) {
        const pathParts = path.resolve(outDirectory).split(path.sep)
        if (pathParts.length === 0) throw new Error("Could not generate font-name. Please provide --font-name (-F) argument.")
        fontName = pathParts.pop()
        fontName = fontName.replace(/_/gi, " ")
    }
    return fontName
}

export default async function main() {

    const {
        override,
        sourceDirectory,
        targetFile,
        fontName: fontNameArgument,
        verbose
    } = extractArguments()

    const {
        fontName,
        sourceDirectoryFullPath,
        outputFileFullPath
    } = getAbsolutePaths({
        fontName: fontNameArgument,
        sourceDirectory,
        targetFile
    })

    const fontFiles = {}

    const files = await readdir(sourceDirectoryFullPath)
    for (let file of files) {

        const ext = extname(file)
        if (supportedFontFileTypes.indexOf(ext) !== -1) {

            let fontWeight = getFontWeight(file)
            let fontStyle = getFontStyle(file)

            if (!fontFiles[fontWeight]) fontFiles[fontWeight] = { normal: {}, italic: {} }

            if (fontFiles[fontWeight][fontStyle][ext]) {
                console.error(`Duplicate font detected:\n
                weight=${fontWeight}, style=${fontStyle}, ext=${ext}\n
                a:${fontFiles[fontWeight][fontStyle][ext]}\nb:${file}`
                )
            } else {
                if (verbose)
                    console.log(`${fontName}::${fontWeight}/${fontStyle}/${ext}: ${file}`)
                fontFiles[fontWeight][fontStyle][ext] = file
            }

        }
    }

    const flags = override ? "w" : "a"
    const writeStream = createWriteStream(outputFileFullPath, { flags })
    writeStream.write(`/*\nThis file was generated by font-facer from the font files in the dir:\n${useForwardSlashes(sourceDirectory)}\n*/\n\n`)

    for (const [weight, { italic, normal }] of Object.entries(fontFiles)) {

        if (Object.keys(normal).length > 0) {
            let src = srcFromTypeObject(sourceDirectory, italic)
            const fontFace = generateFontFace(fontName, weight, "normal", src)
            writeStream.write(fontFace)
        }

        if (Object.keys(italic).length > 0) {
            let src = srcFromTypeObject(sourceDirectory, italic)
            const fontFace = generateFontFace(fontName, weight, "italic", src)
            writeStream.write(fontFace)
        }
    }
}

/**
 * Windows uses by default backward slashes for paths
 * but usually also accepts forward slashes.
 * 
 * Therefore we simply unify those paths into forward slashes.
 */
function useForwardSlashes(path){
    return path.replace(/\\/g, "/")
}

function generateFontFace(name, weight, style, src) {
    return `@font-face {\n    font-family: "${name}";\n    font-weight: ${weight};\n    font-style: ${style};\n    src: ${src};\n}\n\n`
}

function srcFromTypeObject(fontDirectory, typeObject) {
    return Object.values(typeObject).map((filename) => `url('${useForwardSlashes(fontDirectory)}/${filename}')`).join(", ")
}

function getFontStyle(filename) {
    return filename.match(/italic/gi) ? 'italic' : 'normal'
}

function getFontWeight(filename) {
    let fontWeight = normalWeight
    for (let { name, weight } of weights) {
        let weightRegex = new RegExp(name, "gi")
        if (filename.match(weightRegex)) {
            fontWeight = weight
            break
        }
    }
    return fontWeight
}

await main().catch(console.error)